import torch

from GCN import optimizer

#默认的张量存储在CPU上
ts1 = torch.randn(3,4)
#移到GPU上
ts2 = ts1.to('cuda:0')#第一块GPU是cuda:0

#搭建神经网络的类
class DNN(torch.nn.Module):

#根据神经网络的类创建一个网络
model = DNN.to('cuda:0')#把该网络搬到GPU上

'''------------------------------------------------------------------------'''
import torch
import torch.nn as nn
import matplotlib.pyplot as plt
#展示高清图
from matplotlib_inline import backend_inline
backend_inline.set_matplotlib_formats('svg')

#生成数据集
X1 = torch.rand(10000,1)
X2 = torch.rand(10000,1)
X3 = torch.rand(10000,1)

#三列输出特征
Y1 = ( (X1+X2+X3)<1 ).float()
Y2 = ( (1<(X1+X2+X3)) & ((X1+X2+X3)<2) ).float()
Y3 = ( (X1+X2+X3)>2 ).float()

Data = torch.cat([X1,X2,X3,Y1,Y2,Y3],axis=1)#缝合数据集
Data = Data.to('cuda:0')#把数据集搬到GPU上

#划分训练集和测试集
train_size = int(len(Data) * 0.7)
test_size = len(Data) - train_size
Data = Data[torch.randperm(Data.size(0)), : ]#打乱样本的顺序
train_Data = Data[:train_size, : ]#(第0行开始到第7000行，所有的6列)
test_Data = Data[train_size:, : ]#(7000行开始到末尾，所有的6列)


#搭建神经网络
class DNN(nn.Module):
    def __init__(self):
        '''搭建神经网络各层'''
        super(DNN,self).__init__()
        self.net = nn.Sequential(   #按照顺序搭建各层
            nn.Linear(3,5),nn.ReLU(),   #第一层：全连接层
            nn.Linear(5, 5), nn.ReLU(),
            nn.Linear(5, 5), nn.ReLU(),
            nn.Linear(5, 3)
    )
    def forward(self, x ):
        '''前向传播'''
        y = self.net(x) #x即输入数据
        return y        #y即输出数据

#创建子类的实例,并搬到GPU上
model = DNN().to('cuda:0')
#定义损失函数
loss_fn = nn.MSELoss()

#训练网络
epochs = 1000
losses = []     #记录损失函数变化的列表
#给训练集划分输入与输出
X = train_Data[:, :3]   #前三列为输入特征
Y = train_Data[:, -3:]  #倒数三列三列为输出特征

for epoch in range(epochs):
    Pred = model(X)                 #一次前向传播(BGD)
    loss = loss_fn(Pred, Y)         #计算损失函数
    losses.append(loss.item())      #记录损失函数的变化(把损失函数通过.item降级为1个python普通元素)
    optimizer.zero_grad()           #清理上一轮滞留的梯度
    loss.backward()                 #一次反向传播
    optimizer.step()                #优化内部参数

Fig = plt.figure()
plt.plot(range(epochs),losses)
plt.ylabel('loss')
plt.xlabel('epoch')
plt.show()


#测试网络

#给测试集划分输入与输出
X = test_Data[:, :3]
Y = test_Data[:,-3: ]
with torch.no_grad():
    Pred = model(X)
    Pred[:,torch.argmax(Pred, axis=1)] = 1
    Pred[Pred!=1] = 0
    correct = torch.sum( (Pred == Y).all(1) )   #预测正确的样本
    total = Y.size(0)                           #全部的样本数量
    print(f'测试集精确度: {100*correct/total}%')


#保存和导入网络
torch.save(model,'model.pth')
new_model = torch.load('model.pth')

#用新网络跑测试集
X = test_Data[:, :3]
Y = test_Data[:,-3: ]
with torch.no_grad():
    Pred = new_model(X)
    Pred[:,torch.argmax(Pred, axis=1)] = 1
    Pred[Pred!=1] = 0
    correct = torch.sum( (Pred == Y).all(1) )   #预测正确的样本
    total = Y.size(0)                           #全部的样本数量
    print(f'测试集精确度: {100*correct/total}%')

